import { toRefs, ref, reactive, defineComponent, provide, onMounted, renderSlot, inject, onUnmounted } from "vue";
var t = function(e2, n2) {
  return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t2, e3) {
    t2.__proto__ = e3;
  } || function(t2, e3) {
    for (var n3 in e3)
      Object.prototype.hasOwnProperty.call(e3, n3) && (t2[n3] = e3[n3]);
  }, t(e2, n2);
};
var e = function() {
  return e = Object.assign || function(t2) {
    for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
      for (var i2 in e2 = arguments[n2])
        Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
    return t2;
  }, e.apply(this, arguments);
};
function n(t2, e2, n2, r2) {
  return new (n2 || (n2 = Promise))(function(i2, o2) {
    function s2(t3) {
      try {
        c2(r2.next(t3));
      } catch (t4) {
        o2(t4);
      }
    }
    function a2(t3) {
      try {
        c2(r2.throw(t3));
      } catch (t4) {
        o2(t4);
      }
    }
    function c2(t3) {
      var e3;
      t3.done ? i2(t3.value) : (e3 = t3.value, e3 instanceof n2 ? e3 : new n2(function(t4) {
        t4(e3);
      })).then(s2, a2);
    }
    c2((r2 = r2.apply(t2, e2 || [])).next());
  });
}
function r(t2, e2) {
  var n2, r2, i2, o2, s2 = { label: 0, sent: function() {
    if (1 & i2[0])
      throw i2[1];
    return i2[1];
  }, trys: [], ops: [] };
  return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, typeof Symbol == "function" && (o2[Symbol.iterator] = function() {
    return this;
  }), o2;
  function a2(a3) {
    return function(c2) {
      return function(a4) {
        if (n2)
          throw new TypeError("Generator is already executing.");
        for (; o2 && (o2 = 0, a4[0] && (s2 = 0)), s2; )
          try {
            if (n2 = 1, r2 && (i2 = 2 & a4[0] ? r2.return : a4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, a4[1])).done)
              return i2;
            switch (r2 = 0, i2 && (a4 = [2 & a4[0], i2.value]), a4[0]) {
              case 0:
              case 1:
                i2 = a4;
                break;
              case 4:
                return s2.label++, { value: a4[1], done: false };
              case 5:
                s2.label++, r2 = a4[1], a4 = [0];
                continue;
              case 7:
                a4 = s2.ops.pop(), s2.trys.pop();
                continue;
              default:
                if (!(i2 = s2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || a4[0] !== 6 && a4[0] !== 2)) {
                  s2 = 0;
                  continue;
                }
                if (a4[0] === 3 && (!i2 || a4[1] > i2[0] && a4[1] < i2[3])) {
                  s2.label = a4[1];
                  break;
                }
                if (a4[0] === 6 && s2.label < i2[1]) {
                  s2.label = i2[1], i2 = a4;
                  break;
                }
                if (i2 && s2.label < i2[2]) {
                  s2.label = i2[2], s2.ops.push(a4);
                  break;
                }
                i2[2] && s2.ops.pop(), s2.trys.pop();
                continue;
            }
            a4 = e2.call(t2, s2);
          } catch (t3) {
            a4 = [6, t3], r2 = 0;
          } finally {
            n2 = i2 = 0;
          }
        if (5 & a4[0])
          throw a4[1];
        return { value: a4[0] ? a4[1] : void 0, done: true };
      }([a3, c2]);
    };
  }
}
typeof SuppressedError == "function" && SuppressedError;
var i = { exports: {} };
function o() {
}
o.prototype = { on: function(t2, e2, n2) {
  var r2 = this.e || (this.e = {});
  return (r2[t2] || (r2[t2] = [])).push({ fn: e2, ctx: n2 }), this;
}, once: function(t2, e2, n2) {
  var r2 = this;
  function i2() {
    r2.off(t2, i2), e2.apply(n2, arguments);
  }
  return i2._ = e2, this.on(t2, i2, n2);
}, emit: function(t2) {
  for (var e2 = [].slice.call(arguments, 1), n2 = ((this.e || (this.e = {}))[t2] || []).slice(), r2 = 0, i2 = n2.length; r2 < i2; r2++)
    n2[r2].fn.apply(n2[r2].ctx, e2);
  return this;
}, off: function(t2, e2) {
  var n2 = this.e || (this.e = {}), r2 = n2[t2], i2 = [];
  if (r2 && e2)
    for (var o2 = 0, s2 = r2.length; o2 < s2; o2++)
      r2[o2].fn !== e2 && r2[o2].fn._ !== e2 && i2.push(r2[o2]);
  return i2.length ? n2[t2] = i2 : delete n2[t2], this;
} }, i.exports = o;
var s = i.exports.TinyEmitter = o, a = function(t2) {
  var e2 = t2[1];
  return e2 != null;
}, c = function() {
}, u = function() {
  function t2(t3) {
    var e2 = t3.onError, n2 = t3.onSent, r2 = t3.appName, i2 = t3.metricsInterval, o2 = t3.disableMetrics, s2 = o2 !== void 0 && o2, a2 = t3.url, u2 = t3.clientKey, h2 = t3.fetch, l2 = t3.headerName, p2 = t3.customHeaders, f2 = p2 === void 0 ? {} : p2;
    this.onError = e2, this.onSent = n2 || c, this.disabled = s2, this.metricsInterval = 1e3 * i2, this.appName = r2, this.url = a2 instanceof URL ? a2 : new URL(a2), this.clientKey = u2, this.bucket = this.createEmptyBucket(), this.fetch = h2, this.headerName = l2, this.customHeaders = f2;
  }
  return t2.prototype.start = function() {
    var t3 = this;
    if (this.disabled)
      return false;
    typeof this.metricsInterval == "number" && this.metricsInterval > 0 && setTimeout(function() {
      t3.startTimer(), t3.sendMetrics();
    }, 2e3);
  }, t2.prototype.stop = function() {
    this.timer && (clearTimeout(this.timer), delete this.timer);
  }, t2.prototype.createEmptyBucket = function() {
    return { start: new Date(), stop: null, toggles: {} };
  }, t2.prototype.getHeaders = function() {
    var t3, e2 = ((t3 = {})[this.headerName] = this.clientKey, t3.Accept = "application/json", t3["Content-Type"] = "application/json", t3);
    return Object.entries(this.customHeaders).filter(a).forEach(function(t4) {
      var n2 = t4[0], r2 = t4[1];
      return e2[n2] = r2;
    }), e2;
  }, t2.prototype.sendMetrics = function() {
    return n(this, void 0, void 0, function() {
      var t3, e2, n2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (t3 = "".concat(this.url, "/client/metrics"), e2 = this.getPayload(), this.bucketIsEmpty(e2))
              return [2];
            r2.label = 1;
          case 1:
            return r2.trys.push([1, 3, , 4]), [4, this.fetch(t3, { cache: "no-cache", method: "POST", headers: this.getHeaders(), body: JSON.stringify(e2) })];
          case 2:
            return r2.sent(), this.onSent(e2), [3, 4];
          case 3:
            return n2 = r2.sent(), console.error("Unleash: unable to send feature metrics", n2), this.onError(n2), [3, 4];
          case 4:
            return [2];
        }
      });
    });
  }, t2.prototype.count = function(t3, e2) {
    return !(this.disabled || !this.bucket) && (this.assertBucket(t3), this.bucket.toggles[t3][e2 ? "yes" : "no"]++, true);
  }, t2.prototype.countVariant = function(t3, e2) {
    return !(this.disabled || !this.bucket) && (this.assertBucket(t3), this.bucket.toggles[t3].variants[e2] ? this.bucket.toggles[t3].variants[e2] += 1 : this.bucket.toggles[t3].variants[e2] = 1, true);
  }, t2.prototype.assertBucket = function(t3) {
    if (this.disabled || !this.bucket)
      return false;
    this.bucket.toggles[t3] || (this.bucket.toggles[t3] = { yes: 0, no: 0, variants: {} });
  }, t2.prototype.startTimer = function() {
    var t3 = this;
    this.timer = setInterval(function() {
      t3.sendMetrics();
    }, this.metricsInterval);
  }, t2.prototype.bucketIsEmpty = function(t3) {
    return Object.keys(t3.bucket.toggles).length === 0;
  }, t2.prototype.getPayload = function() {
    var t3 = e(e({}, this.bucket), { stop: new Date() });
    return this.bucket = this.createEmptyBucket(), { bucket: t3, appName: this.appName, instanceId: "browser" };
  }, t2;
}(), h = function() {
  function t2() {
    this.store = /* @__PURE__ */ new Map();
  }
  return t2.prototype.save = function(t3, e2) {
    return n(this, void 0, void 0, function() {
      return r(this, function(n2) {
        return this.store.set(t3, e2), [2];
      });
    });
  }, t2.prototype.get = function(t3) {
    return n(this, void 0, void 0, function() {
      return r(this, function(e2) {
        return [2, this.store.get(t3)];
      });
    });
  }, t2;
}(), l = function() {
  function t2() {
    this.prefix = "unleash:repository";
  }
  return t2.prototype.save = function(t3, e2) {
    return n(this, void 0, void 0, function() {
      var n2, i2;
      return r(this, function(r2) {
        n2 = JSON.stringify(e2), i2 = "".concat(this.prefix, ":").concat(t3);
        try {
          window.localStorage.setItem(i2, n2);
        } catch (t4) {
          console.error(t4);
        }
        return [2];
      });
    });
  }, t2.prototype.get = function(t3) {
    try {
      var e2 = "".concat(this.prefix, ":").concat(t3), n2 = window.localStorage.getItem(e2);
      return n2 ? JSON.parse(n2) : void 0;
    } catch (t4) {
      console.error(t4);
    }
  }, t2;
}();
let p;
const f = new Uint8Array(16);
function d() {
  if (!p && (p = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !p))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return p(f);
}
const v = [];
for (let t2 = 0; t2 < 256; ++t2)
  v.push((t2 + 256).toString(16).slice(1));
var m = { randomUUID: typeof crypto != "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto) };
function y(t2, e2, n2) {
  if (m.randomUUID && !e2 && !t2)
    return m.randomUUID();
  const r2 = (t2 = t2 || {}).random || (t2.rng || d)();
  if (r2[6] = 15 & r2[6] | 64, r2[8] = 63 & r2[8] | 128, e2) {
    n2 = n2 || 0;
    for (let t3 = 0; t3 < 16; ++t3)
      e2[n2 + t3] = r2[t3];
    return e2;
  }
  return function(t3, e3 = 0) {
    return v[t3[e3 + 0]] + v[t3[e3 + 1]] + v[t3[e3 + 2]] + v[t3[e3 + 3]] + "-" + v[t3[e3 + 4]] + v[t3[e3 + 5]] + "-" + v[t3[e3 + 6]] + v[t3[e3 + 7]] + "-" + v[t3[e3 + 8]] + v[t3[e3 + 9]] + "-" + v[t3[e3 + 10]] + v[t3[e3 + 11]] + v[t3[e3 + 12]] + v[t3[e3 + 13]] + v[t3[e3 + 14]] + v[t3[e3 + 15]];
  }(r2);
}
var g = function() {
  function t2() {
  }
  return t2.prototype.generateEventId = function() {
    return y();
  }, t2.prototype.createImpressionEvent = function(t3, n2, r2, i2, o2, s2) {
    var a2 = this.createBaseEvent(t3, n2, r2, i2, o2);
    return s2 ? e(e({}, a2), { variant: s2 }) : a2;
  }, t2.prototype.createBaseEvent = function(t3, e2, n2, r2, i2) {
    return { eventType: r2, eventId: this.generateEventId(), context: t3, enabled: e2, featureName: n2, impressionData: i2 };
  }, t2;
}(), b = ["userId", "sessionId", "remoteAddress"], w = { INIT: "initialized", ERROR: "error", READY: "ready", UPDATE: "update", IMPRESSION: "impression", SENT: "sent" }, E = "isEnabled", I = "getVariant", x = { name: "disabled", enabled: false, feature_enabled: false }, R = "repo", S = function() {
  try {
    if (typeof window != "undefined" && "fetch" in window)
      return fetch.bind(window);
    if ("fetch" in globalThis)
      return fetch.bind(globalThis);
  } catch (t2) {
    console.error('Unleash failed to resolve "fetch"', t2);
  }
}, T = function(i2) {
  function o2(t2) {
    var n2 = t2.storageProvider, r2 = t2.url, o3 = t2.clientKey, s2 = t2.disableRefresh, a2 = s2 !== void 0 && s2, c2 = t2.refreshInterval, p2 = c2 === void 0 ? 30 : c2, f2 = t2.metricsInterval, d2 = f2 === void 0 ? 30 : f2, v2 = t2.disableMetrics, m2 = v2 !== void 0 && v2, y2 = t2.appName, b2 = t2.environment, E2 = b2 === void 0 ? "default" : b2, I2 = t2.context, x2 = t2.fetch, R2 = x2 === void 0 ? S() : x2, T2 = t2.bootstrap, O = t2.bootstrapOverride, N = O === void 0 || O, k = t2.headerName, D = k === void 0 ? "Authorization" : k, U = t2.customHeaders, P = U === void 0 ? {} : U, A = t2.impressionDataAll, j = A !== void 0 && A, H = t2.usePOSTrequests, M = H !== void 0 && H, _ = i2.call(this) || this;
    if (_.toggles = [], _.etag = "", _.readyEventEmitted = false, _.usePOSTrequests = false, _.started = false, !r2)
      throw new Error("url is required");
    if (!o3)
      throw new Error("clientKey is required");
    if (!y2)
      throw new Error("appName is required.");
    return _.eventsHandler = new g(), _.impressionDataAll = j, _.toggles = T2 && T2.length > 0 ? T2 : [], _.url = r2 instanceof URL ? r2 : new URL(r2), _.clientKey = o3, _.headerName = D, _.customHeaders = P, _.storage = n2 || (typeof window != "undefined" ? new l() : new h()), _.refreshInterval = a2 ? 0 : 1e3 * p2, _.context = e({ appName: y2, environment: E2 }, I2), _.usePOSTrequests = M, _.ready = new Promise(function(t3) {
      _.init().then(t3).catch(function(e2) {
        console.error(e2), _.emit(w.ERROR, e2), t3();
      });
    }), R2 || console.error('Unleash: You must either provide your own "fetch" implementation or run in an environment where "fetch" is available.'), _.fetch = R2, _.bootstrap = T2 && T2.length > 0 ? T2 : void 0, _.bootstrapOverride = N, _.metrics = new u({ onError: _.emit.bind(_, w.ERROR), onSent: _.emit.bind(_, w.SENT), appName: y2, metricsInterval: d2, disableMetrics: m2, url: _.url, clientKey: o3, fetch: R2, headerName: D, customHeaders: P }), _;
  }
  return function(e2, n2) {
    if (typeof n2 != "function" && n2 !== null)
      throw new TypeError("Class extends value " + String(n2) + " is not a constructor or null");
    function r2() {
      this.constructor = e2;
    }
    t(e2, n2), e2.prototype = n2 === null ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
  }(o2, i2), o2.prototype.getAllToggles = function() {
    return function(t2, e2, n2) {
      if (n2 || arguments.length === 2)
        for (var r2, i3 = 0, o3 = e2.length; i3 < o3; i3++)
          !r2 && i3 in e2 || (r2 || (r2 = Array.prototype.slice.call(e2, 0, i3)), r2[i3] = e2[i3]);
      return t2.concat(r2 || Array.prototype.slice.call(e2));
    }([], this.toggles, true);
  }, o2.prototype.isEnabled = function(t2) {
    var e2, n2 = this.toggles.find(function(e3) {
      return e3.name === t2;
    }), r2 = !!n2 && n2.enabled;
    if (this.metrics.count(t2, r2), (n2 == null ? void 0 : n2.impressionData) || this.impressionDataAll) {
      var i3 = this.eventsHandler.createImpressionEvent(this.context, r2, t2, E, (e2 = n2 == null ? void 0 : n2.impressionData) !== null && e2 !== void 0 ? e2 : void 0);
      this.emit(w.IMPRESSION, i3);
    }
    return r2;
  }, o2.prototype.getVariant = function(t2) {
    var n2, r2 = this.toggles.find(function(e2) {
      return e2.name === t2;
    }), i3 = (r2 == null ? void 0 : r2.enabled) || false, o3 = r2 ? r2.variant : x;
    if (o3.name && this.metrics.countVariant(t2, o3.name), this.metrics.count(t2, i3), (r2 == null ? void 0 : r2.impressionData) || this.impressionDataAll) {
      var s2 = this.eventsHandler.createImpressionEvent(this.context, i3, t2, I, (n2 = r2 == null ? void 0 : r2.impressionData) !== null && n2 !== void 0 ? n2 : void 0, o3.name);
      this.emit(w.IMPRESSION, s2);
    }
    return e(e({}, o3), { feature_enabled: i3 });
  }, o2.prototype.updateContext = function(t2) {
    return n(this, void 0, void 0, function() {
      var n2, i3 = this;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            return (t2.appName || t2.environment) && console.warn("appName and environment are static. They can't be updated with updateContext."), n2 = { environment: this.context.environment, appName: this.context.appName, sessionId: this.context.sessionId }, this.context = e(e({}, n2), t2), this.timerRef || this.readyEventEmitted ? [4, this.fetchToggles()] : [3, 2];
          case 1:
            return r2.sent(), [3, 4];
          case 2:
            return this.started ? [4, new Promise(function(t3) {
              var e2 = function() {
                i3.fetchToggles().then(function() {
                  i3.off(w.READY, e2), t3();
                });
              };
              i3.once(w.READY, e2);
            })] : [3, 4];
          case 3:
            r2.sent(), r2.label = 4;
          case 4:
            return [2];
        }
      });
    });
  }, o2.prototype.getContext = function() {
    return e({}, this.context);
  }, o2.prototype.setContextField = function(t2, n2) {
    var r2, i3;
    if (b.includes(t2))
      this.context = e(e({}, this.context), ((r2 = {})[t2] = n2, r2));
    else {
      var o3 = e(e({}, this.context.properties), ((i3 = {})[t2] = n2, i3));
      this.context = e(e({}, this.context), { properties: o3 });
    }
    this.timerRef && this.fetchToggles();
  }, o2.prototype.init = function() {
    return n(this, void 0, void 0, function() {
      var t2, n2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            return [4, this.resolveSessionId()];
          case 1:
            return t2 = r2.sent(), this.context = e({ sessionId: t2 }, this.context), n2 = this, [4, this.storage.get(R)];
          case 2:
            return n2.toggles = r2.sent() || [], !this.bootstrap || !this.bootstrapOverride && this.toggles.length !== 0 ? [3, 4] : [4, this.storage.save(R, this.bootstrap)];
          case 3:
            r2.sent(), this.toggles = this.bootstrap, this.emit(w.READY), r2.label = 4;
          case 4:
            return this.emit(w.INIT), [2];
        }
      });
    });
  }, o2.prototype.start = function() {
    return n(this, void 0, void 0, function() {
      var t2, e2 = this;
      return r(this, function(n2) {
        switch (n2.label) {
          case 0:
            return this.started = true, this.timerRef ? (console.error("Unleash SDK has already started, if you want to restart the SDK you should call client.stop() before starting again."), [2]) : [4, this.ready];
          case 1:
            return n2.sent(), this.metrics.start(), t2 = this.refreshInterval, [4, this.fetchToggles()];
          case 2:
            return n2.sent(), t2 > 0 && (this.timerRef = setInterval(function() {
              return e2.fetchToggles();
            }, t2)), [2];
        }
      });
    });
  }, o2.prototype.stop = function() {
    this.timerRef && (clearInterval(this.timerRef), this.timerRef = void 0), this.metrics.stop();
  }, o2.prototype.resolveSessionId = function() {
    return n(this, void 0, void 0, function() {
      var t2;
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return this.context.sessionId ? [2, this.context.sessionId] : [3, 1];
          case 1:
            return [4, this.storage.get("sessionId")];
          case 2:
            return (t2 = e2.sent()) ? [3, 4] : (t2 = Math.floor(1e9 * Math.random()), [4, this.storage.save("sessionId", t2)]);
          case 3:
            e2.sent(), e2.label = 4;
          case 4:
            return [2, t2];
        }
      });
    });
  }, o2.prototype.getHeaders = function() {
    var t2, e2 = ((t2 = {})[this.headerName] = this.clientKey, t2.Accept = "application/json", t2["Content-Type"] = "application/json", t2["If-None-Match"] = this.etag, t2);
    return Object.entries(this.customHeaders).filter(a).forEach(function(t3) {
      var n2 = t3[0], r2 = t3[1];
      return e2[n2] = r2;
    }), e2;
  }, o2.prototype.storeToggles = function(t2) {
    return n(this, void 0, void 0, function() {
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return this.toggles = t2, this.emit(w.UPDATE), [4, this.storage.save(R, t2)];
          case 1:
            return e2.sent(), [2];
        }
      });
    });
  }, o2.prototype.fetchToggles = function() {
    return n(this, void 0, void 0, function() {
      var t2, e2, n2, i3, o3, s2, c2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (!this.fetch)
              return [3, 8];
            r2.label = 1;
          case 1:
            return r2.trys.push([1, 7, , 8]), t2 = this.usePOSTrequests, e2 = t2 ? this.url : function(t3, e3) {
              var n3 = new URL(t3.toString());
              return Object.entries(e3).filter(a).forEach(function(t4) {
                var e4 = t4[0], r3 = t4[1];
                e4 === "properties" && r3 ? Object.entries(r3).filter(a).forEach(function(t5) {
                  var e5 = t5[0], r4 = t5[1];
                  return n3.searchParams.append("properties[".concat(e5, "]"), r4);
                }) : n3.searchParams.append(e4, r3);
              }), n3;
            }(this.url, this.context), n2 = t2 ? "POST" : "GET", i3 = t2 ? JSON.stringify({ context: this.context }) : void 0, [4, this.fetch(e2.toString(), { method: n2, cache: "no-cache", headers: this.getHeaders(), body: i3 })];
          case 2:
            return (o3 = r2.sent()).ok && o3.status !== 304 ? (this.etag = o3.headers.get("ETag") || "", [4, o3.json()]) : [3, 5];
          case 3:
            return s2 = r2.sent(), [4, this.storeToggles(s2.toggles)];
          case 4:
            return r2.sent(), this.bootstrap || this.readyEventEmitted || (this.emit(w.READY), this.readyEventEmitted = true), [3, 6];
          case 5:
            o3.ok || o3.status === 304 || (console.error("Unleash: Fetching feature toggles did not have an ok response"), this.emit(w.ERROR, { type: "HttpError", code: o3.status })), r2.label = 6;
          case 6:
            return [3, 8];
          case 7:
            return c2 = r2.sent(), console.error("Unleash: unable to fetch feature toggles", c2), this.emit(w.ERROR, c2), [3, 8];
          case 8:
            return [2];
        }
      });
    });
  }, o2;
}(s);
const ContextStateSymbol = Symbol("Context state identifier");
const ContextUpdateSymbol = Symbol("Context update identifier");
function useUnleashProvide({
  config,
  unleashClient,
  startClient = true
}) {
  var _a, _b;
  const client = ref(unleashClient);
  const flagsReady = ref(false);
  const flagsError = ref(null);
  if (!config && !unleashClient) {
    console.warn(`You must provide either a config or an unleash client to the flag provider. If you are initializing the client in useEffect, you can avoid this warning by
    checking if the client exists before rendering.`);
  }
  if (!client.value && config) {
    client.value = new T(config);
  }
  (_a = client.value) == null ? void 0 : _a.on("ready", () => {
    flagsReady.value = true;
  });
  (_b = client.value) == null ? void 0 : _b.on("error", (e2) => {
    flagsError.value = e2;
  });
  const updateContext = async (context2) => {
    var _a2;
    await ((_a2 = client.value) == null ? void 0 : _a2.updateContext(context2));
  };
  const isEnabled = (name) => {
    var _a2;
    return (_a2 = client.value) == null ? void 0 : _a2.isEnabled(name);
  };
  const getVariant = (name) => {
    var _a2;
    return (_a2 = client.value) == null ? void 0 : _a2.getVariant(name);
  };
  const on = (event, ...args) => {
    var _a2;
    return (_a2 = client.value) == null ? void 0 : _a2.on(event, ...args);
  };
  const context = reactive({
    on,
    updateContext,
    isEnabled,
    getVariant,
    client,
    flagsReady,
    flagsError
  });
  const update = (property, value) => {
    context[property] = value;
  };
  const start = () => {
    var _a2;
    if (startClient || !unleashClient) {
      (_a2 = client == null ? void 0 : client.value) == null ? void 0 : _a2.start();
    }
  };
  return {
    context: toRefs(context),
    update,
    start
  };
}
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "FlagProvider",
  props: {
    config: null,
    unleashClient: null,
    startClient: { type: Boolean }
  },
  setup(__props) {
    const {
      config,
      unleashClient,
      startClient = true
    } = __props;
    const { context, start, update } = useUnleashProvide({
      config,
      unleashClient,
      startClient
    });
    provide(ContextStateSymbol, context);
    provide(ContextUpdateSymbol, update);
    onMounted(() => {
      start();
    });
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});
const useFlag = (name) => {
  const { isEnabled, client } = inject(ContextStateSymbol, {});
  const flag = ref(Boolean(isEnabled == null ? void 0 : isEnabled.value(name)));
  function onUpdate() {
    const enabled = isEnabled == null ? void 0 : isEnabled.value(name);
    if (enabled !== flag.value) {
      flag.value = !!enabled;
    }
  }
  function onReady() {
    flag.value = Boolean(isEnabled == null ? void 0 : isEnabled.value(name));
  }
  client == null ? void 0 : client.value.on("ready", onReady);
  client == null ? void 0 : client.value.on("update", onUpdate);
  onUnmounted(() => {
    client == null ? void 0 : client.value.off("ready", onReady);
    client == null ? void 0 : client.value.off("update", onUpdate);
  });
  return flag;
};
const useFlagsStatus = () => {
  const { flagsReady, flagsError } = inject(ContextStateSymbol, {});
  return { flagsReady, flagsError };
};
const variantHasChanged = (oldVariant, newVariant) => {
  var _a, _b, _c, _d;
  const variantsAreEqual = (oldVariant == null ? void 0 : oldVariant.name) === (newVariant == null ? void 0 : newVariant.name) && (oldVariant == null ? void 0 : oldVariant.enabled) === (newVariant == null ? void 0 : newVariant.enabled) && (oldVariant == null ? void 0 : oldVariant.feature_enabled) === (newVariant == null ? void 0 : newVariant.feature_enabled) && ((_a = oldVariant == null ? void 0 : oldVariant.payload) == null ? void 0 : _a.type) === ((_b = newVariant == null ? void 0 : newVariant.payload) == null ? void 0 : _b.type) && ((_c = oldVariant == null ? void 0 : oldVariant.payload) == null ? void 0 : _c.value) === ((_d = newVariant == null ? void 0 : newVariant.payload) == null ? void 0 : _d.value);
  return !variantsAreEqual;
};
const useVariant = (name) => {
  const { getVariant, client } = inject(ContextStateSymbol, {});
  const variant = ref(getVariant == null ? void 0 : getVariant.value(name));
  function onUpdate() {
    const newVariant = getVariant == null ? void 0 : getVariant.value(name);
    if (variantHasChanged(variant == null ? void 0 : variant.value, newVariant)) {
      variant.value = newVariant;
    }
  }
  function onReady() {
    variant.value = getVariant == null ? void 0 : getVariant.value(name);
  }
  client == null ? void 0 : client.value.on("ready", onReady);
  client == null ? void 0 : client.value.on("update", onUpdate);
  onUnmounted(() => {
    client == null ? void 0 : client.value.off("ready", onReady);
    client == null ? void 0 : client.value.off("update", onUpdate);
  });
  return variant || {};
};
const useUnleashContext = () => {
  const { updateContext } = inject(ContextStateSymbol, {});
  return updateContext == null ? void 0 : updateContext.value;
};
const useUnleashClient = () => {
  const { client } = inject(ContextStateSymbol, {});
  return client == null ? void 0 : client.value;
};
const plugin = {
  install(app, { config, unleashClient, startClient }) {
    const { context, update, start } = useUnleashProvide({
      config,
      unleashClient,
      startClient
    });
    app.provide(ContextStateSymbol, context);
    app.provide(ContextUpdateSymbol, update);
    start();
  }
};
export { ContextStateSymbol, ContextUpdateSymbol, _sfc_main as FlagProvider, h as InMemoryStorageProvider, l as LocalStorageProvider, T as UnleashClient, _sfc_main as default, plugin, useFlag, useFlagsStatus, useUnleashClient, useUnleashContext, useVariant };
